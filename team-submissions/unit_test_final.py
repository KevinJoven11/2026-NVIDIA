# -*- coding: utf-8 -*-
"""unit_test.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1IpQXrcibHzrcCYnJJvIvwAZfoQzmCXg2

# Verification Test: Autocorrelation Flip Invariance

**Purpose:**  
This test verifies that the autocorrelation energy calculation is invariant under a global bit flip. Flipping all `0`s to `1`s and all `1`s to `0`s in a sequence should not change the autocorrelation energy.

**Rationale:**  
The autocorrelation function maps bits to `-1` and `+1` (`0 → -1`, `1 → +1`) and then sums the squares of shifted products. Flipping all bits multiplies every value by `-1`, but squaring cancels the sign, leaving the energy unchanged.

**Checks:**  
- Correct handling of bit flips in sequences.  
- Proper implementation of the `{0,1} → {-1,+1}` mapping.  
- Consistent results even when sequences are inverted.

**Conclusion:**  
If this test passes, the autocorrelation calculation respects a fundamental symmetry and is robust to bit inversion, confirming correctness for sequences of 0s and 1s.
"""

# autocorr.py
import numpy as np

def autocorrelation(sequence):
    n = len(sequence)
    # Map {0,1} → {-1,+1}
    s = np.array([1 if bit == 1 else -1 for bit in sequence], dtype=int)
    energy = 0
    for k in range(1, n):
        C_k = sum(s[i] * s[i + k] for i in range(n - k))
        energy += C_k ** 2
    return energy


def autocorrelation_from_results(best_strings_dict):
    results = {}
    for N, seq in best_strings_dict.items():
        sequence = [int(bit) for bit in seq]
        results[N] = autocorrelation(sequence)
    return results


def flip_best_strings(best_strings):
    flipped = {}
    for N, seq in best_strings.items():
        flipped[N] = [1 - int(bit) for bit in seq]
    return flipped

import numpy as np
from autocorr import (
    autocorrelation,
    autocorrelation_from_results,
    flip_best_strings
)

def test_autocorrelation_known_values():
    # All zeros → all -1 after mapping
    seq = [0, 0, 0, 0]
    # s = [-1, -1, -1, -1]
    # C1 = 3, C2 = 2, C3 = 1 → energy = 9 + 4 + 1 = 14
    assert autocorrelation(seq) == 14

    # Alternating pattern
    seq = [0, 1, 0, 1]
    # s = [-1, 1, -1, 1]
    # C1 = -3, C2 = 2, C3 = -1 → energy = 9 + 4 + 1 = 14
    assert autocorrelation(seq) == 14

def test_autocorrelation_short_sequences():
    assert autocorrelation([0]) == 0
    assert autocorrelation([1]) == 0

    # Only k=1 contributes
    assert autocorrelation([0, 0]) == 1
    assert autocorrelation([0, 1]) == 1

def test_autocorrelation_from_results():
    best_strings = {
        4: [0, 0, 0, 0],
        5: [1, 0, 1, 0, 1],
    }

    results = autocorrelation_from_results(best_strings)

    assert isinstance(results, dict)
    assert set(results.keys()) == {4, 5}
    assert results[4] == autocorrelation([0, 0, 0, 0])
    assert results[5] == autocorrelation([1, 0, 1, 0, 1])

def test_flip_invariance():
    best_strings = {
        6: [0, 1, 1, 0, 1, 0],
        7: [1, 1, 0, 0, 1, 0, 1],
    }

    flipped = flip_best_strings(best_strings)

    original_scores = autocorrelation_from_results(best_strings)
    flipped_scores = autocorrelation_from_results(flipped)

    assert original_scores == flipped_scores

def test_numpy_int_inputs():
    seq = [np.int64(0), np.int64(1), np.int64(0), np.int64(1)]
    assert autocorrelation(seq) == autocorrelation([0, 1, 0, 1])